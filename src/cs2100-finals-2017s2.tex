\documentclass[a4paper]{article} \usepackage[backend=biber, style=numeric, sorting=none]{biblatex}
\usepackage[a4paper, left=1cm, right=1cm, top=1cm, bottom=1cm, landscape]{geometry}
% \usepackage{showframe}
\usepackage{multicol}
\usepackage{blindtext}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{enumitem}
\graphicspath{{images/cs2100/}}

\begin{document}
\setlength\parindent{0pt} %TODO this somehow messes up paragraph vertical spacing as well?
\scriptsize
% \tiny
\pagenumbering{gobble}

\begin{center}
{\large CS2100 Cheatsheet 2017}\\{by vig}
\end{center}
    \begin{multicols*}{4}

% NUMBER SYSTEMS & DATA REPRESENTATION %
{\small\textbf{Number Systems \& Data Representation }}
\textbf{Sizes of data/types}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item byte : 8 bits \item nibble : 4 bits (half-word)
\item word : multiple bytes (1, 2, 4) (for MIPS it's 4)
\item \texttt{int} : 4 bytes (1 bit for sign, 31 for magnitude)
\item \texttt{float} : 4 bytes
\item \texttt{double} : 8 bytes
\item \texttt{char} : 1 byte
\end{itemize}

\textbf{Representation \& Complements}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Convert decimal whole numbers to base $R$ : divide by R, first remainder is LSB, last is MSB
\item Convert decimal fractions to base R : multiply by R, first carry is MSB, last is LSB
\item base ${R}$ to base ${R^N}$: partition in groups of $N$ e.g groups of 4 for base 2 to base 16
\item Convert to R-1s complement : Flip the digits; \texttt{digit = R - digit}
\item Convert to Rs complement : Flip the digits, then add 1 to the number
\item 1s complement has +ive and -ive 0
\item 2s complement has only 1 representation of 0
\item 2s complement can represent an \i{additional} negative number e.g for binary, 1000 represents -8 (+8 cannot be represented in a signed 4 bit number)
\item Convert to excess X: Take number minus X (0 refers to -x)
\item IEEE 754 Floating-Point Representation:  $sign  | exponent  |  mantissa$
\item Single-precision float has 1 bit sign, 8 bit excess-127 exponent, 23 bit mantissa (normalized with a leading bit 1 i.e the mantissa is the X in 1.X)
\item Double has 1 bit sign, 11 bit excess-1023 exponent, 52 bit mantissa 
\end{itemize}

\textbf{Operations with binary numbers}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item 2s complement addition: Simply add \& ignore carry out of MSB
\item 2s complement subtraction: take 2s complement of number to be subtracted, then do 2s addition.
\item 1s complement addition: Add; If there is a carry out, add 1 to the result
\item 1s complement subtraction: take 1s complement of number to be subtracted, then do 1s addition.
\item check for \bf{overflow}: If result is opposite sign of both operands (that have the same sign)
\end{itemize}

% MIPS %
{\small\textbf{MIPS}}

\textbf{R, I, J format}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item $\bf{R}$: $Opcode, rs, rt, rd, shamt, funct$
\item $\bf{I}$: $Opcode, rs, rt, Imm$
\item rd is not used, check datasheet for instruction syntax
\item For branch, $Imm$ is the relative number of \i{words} to go to (with respect to $PC + 4$), in Sign and Magnitue representation
\item $\bf{J}$: $Opcode, Address$
\item First 4 bits are assumed to be 4 MSBs of $PC + 4$. Last 2 bits assumed to be 0 (because of word addressing)
\end{itemize}

% Instruction Set Architecture %
{\small\textbf{Instruction Set Architecture}}

\textbf{Architectures \& Endianness}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Von Neumann: Data(operands) stored in memory
\item Stack: operands are on top of stack
\item Accumulator: One operator is in the accumulator (a special register)
\item Memory-memory (all operands in memory)
\item Register-Register (all operands in registers) (MIPS)
\item Big-endian: Most significant byte stored in lowest address
\item Little-endian: Least significant byte stored in lowest address (easier to read)
\end{itemize}

\textbf{Opcode encoding}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item To maximize, reserve 1 instruction for lesser-bit instruction types.
\item To minimize, reserve all but 1 instruction for lesser-bit instruction types
\item Forumla for maximizing: $2^{no. of bits} * (1 - F)$ where $F$ is the fraction of bits lost by reserving bits
\end{itemize}

% Boolean Algebra %
{\small\textbf{Boolean Algebra}}
\textbf{Laws}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Identity: $A + 0 = A$ and $A \cdot 1 = A$
\item Complement: $A + A' = 1$ and $A \cdot A' = 0$
\item Commutative: $A + B = B + A$  and $A \cdot B = B \cdot A$
\item Associative: $A + (B + C) = (A + B) + C$ and $A \cdot (B \cdot C) = (A \cdot B) \cdot C$
\item Distributive: $A + (B \cdot C) = (A + B) \cdot (A + C)$ and $A \cdot (B + C) = (A \cdot B) + (A \cdot C)$
\item Duality (not a real law): If we flip AND/OR operators and flip the operands (0 and 1), the boolean equation still holds
\end{itemize}

\textbf{Theorems}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Idempotency: $X + X = X$ and $X \cdot X = X$
\item One/Zero Element: $X + 1 = 1$ and $X \cdot 0 = 0$
\item Involution: $(X')' = X$ 
\item Absorption: \\ $X + (X \cdot Y) = X$ \\ $X \cdot (X + Y) = X$
\item Absorption (variant): \\ $X + (X' \cdot Y) = X + Y$ \\ $X \cdot (X' + Y) = X \cdot Y$
\item DeMorgans' (can be used on $>2$ variables): \\ $(X \cdot Y)' = X' + Y'$ \\ $(X + Y)' = X' \cdot Y'$
\item Concensus: \\ $(X \cdot Y) + (X' \cdot Z) + (Y \cdot Z) = (X \cdot Y) + (X' \cdot Z)$ \\ $(X + Y) \cdot (X' + Z) \cdot (Y + Z) = (X + Y) \cdot (X' + Z)$
\end{itemize}

\textbf{Minterms \& Maxterms}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Sum-Of-Products (SOP): Product term or a logical sum of product terms
\item $m$interm: Product term that contains $n$ literals from all the variables
\item Product-Of-Sum (POS): Sum term or a logical product of sum terms
\item $M$axterm: Sum term that contains $n$ literals from all the variables
\item $Mx$ = $mx'$ because of De Morgan's
\item Sum of 2 distinct Maxterms is 1 e.g $M1234 + M1120 = 1$
\item Product of 2 distinct minterms is 0 e.g $m1234 \cdot m1120 = 0$
\end{itemize}

% Combinatorial Circuits %
{\small\textbf{Combinatorial Circuits}}
\\ \textbf{Gates}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item {AND, OR, NOT} is a complete set of logic
\item {NAND} is a complete set of logic
\item {NOR} is a complete set of logic
\item Produce SOP with $AND >> OR$ or $NAND >> NAND$
\item Produce POS with $OR >> AND$ or $NOR >> NOR$
\item With negated outputs, use NAND to simulate OR and NOR to simulate AND
\end{itemize}
{\centering \includegraphics[scale=0.1]{nor_nand}}

\textbf{K-maps}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item Prime Implicant (PI) is a product term formed by combining the {\i maximum} possible no. of minterms (largest group)
\item Essential Prime Implicant (EPI) is a PI that includes at least one minterm not covered by any other group
\item Label the K-map rows/columns in a {\i gray code} manner e.g $00, 01, 11, 10$
\item Grouping $2^N$ cells(only power-sizes are allowed) eliminates n variables
\item EPIs are counted only by checking 1s, {\bf not} $X$s
\item K-maps help to obtain canonical SOP, but might not provide the simplest expression possible (need to use boolean algebra for that)
\end{itemize}

\textbf {Delays} \text{: Note that for combinatorial circuits, there is a delay: for every logic gate with $n$ inputs, calculate $delay = max(t_1, t_2, \dots t_n) + t_delay$}
{\centering \includegraphics[scale=0.18]{circuit_delay}}


\textbf{MSI Components}
\textbf{{Decoder}}
\begin{multicols*}{2}
{\centering \includegraphics[scale=0.13]{decoder}}
\vfill\null
\columnbreak
Generate minterms and use OR to form a function
Alternatively, generate maxterms and use NOR
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Multiplexer}}
\\ Use minterm as selection line, using 0/1 as inputs. For smaller size multiplexer, use one of the variables for input lines.
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{multiplexer}}
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Demultiplexer}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{demultiplexer}}
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Encoder}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{encoder}}
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Decoder}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{decoder}}
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Priority Encoder}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{priorityEncoder}}
\end{multicols*}

\begin{multicols*}{2}
\textbf{{Larger Components}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{largerComponents}}
\end{multicols*}

%Sequential Logic%
{\small\textbf{Sequential Logic }}
\\ \textbf{{Excitation Tables}}
\\ {\centering \includegraphics[scale=0.14]{excitationTables}}
\begin{itemize}[leftmargin=*]
\itemsep -0.5em
\item For $m$ flip-flops, up to $2^m$ states exist.
\item SR has invalid code while JK uses that for the toggle code
\item T is the {\i toggle} flip-flop
\item D is the {\i setting} flip-flop
\item Negative input for $Clock$ $\rightarrow$ flip-flop is negative edge-triggered
\end{itemize}

\begin{multicols*}{2}
\textbf{{RAM}}
\vfill\null
\columnbreak
{\centering \includegraphics[scale=0.13]{ram}}
\\ \caption Static RAM
\end{multicols*}

    \end{multicols*}
\end{document}
